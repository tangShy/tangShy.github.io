{"meta":{"title":"Tang's blog","subtitle":"coding、writing、fighting","description":"Coding change world~","author":"Tang Jian","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-03-03T14:04:17.000Z","updated":"2020-03-03T14:09:04.214Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-03T14:06:47.000Z","updated":"2020-03-03T14:07:46.937Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java设计模式学习笔记二","slug":"Java设计模式学习笔记二","date":"2020-03-06T14:09:04.000Z","updated":"2020-03-06T15:18:37.893Z","comments":true,"path":"2020/03/06/Java设计模式学习笔记二/","link":"","permalink":"http://yoursite.com/2020/03/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/","excerpt":"","text":"Java设计模式一般分为三类：创建型、结构型、行为型 共有23种 创建型模式（5个）：单例模式、抽象工厂模式、工厂模式、原型模式、建造者模式 结构型模式（7个）：适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式、代理模式 行为型模式（11个）：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式） 注：各个地方出现的名称可能略有不同（翻译问题） 单例模式 单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法（静态方法）。 单例模式有八种实现方法 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举 1）饿汉式（静态常量） 构造器私有化（防止 new） 类的内部创建对象 向外暴露一个静态的公共方法。getInstance() 代码实现 123456789101112class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private final static Singleton instance = new Singleton(); //3.提供静态公共方法，返回实例对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 优缺点： 优点：简单，在类装载的时候就完成实例化。避免了线程同步的问题。 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。容易造成内存浪费（可能这个实例从始至终未曾使用过） 2）饿汉式（静态代码块） 代码实现 123456789101112131415class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; static &#123; instance = new Singleton() &#125; //3.提供静态公共方法，返回实例对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 优缺点： 这种方法和上面的方法类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。所以优缺点和上面方法是一样的。 3）懒汉式（线程不安全） 构造器私有化 类的内部创建对象实例 提供一个静态的公共方法，当使用到该方法时，采取创建实例 代码实现 12345678910111213141516class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; //3.提供一个静态的公共方法，当使用到该方法时，才去创建实例（需要了才去行动叫懒汉式） public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 优缺点： 优点：起到了 Lazy Loading 的效果，不会造成内存的浪费 只能在单线程下使用，如果多线程下，一个线程进入了 if 判断语句，还未来得及往下执行，另一个线程也通过了这个 if 判断语句，这时便会产生多个实例。 4）懒汉式（线程安全，同步方法） 代码实现 123456789101112131415class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; //3.提供一个静态的公共方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优缺点： 优点：解决了线程安全问题 缺点：效率太低，每次获取实例的时候都要进行同步操作，同步效率太低。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记","slug":"Java设计模式学习笔记","date":"2020-03-03T13:51:20.000Z","updated":"2020-03-05T05:56:34.324Z","comments":true,"path":"2020/03/03/Java设计模式学习笔记/","link":"","permalink":"http://yoursite.com/2020/03/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"谈起设计模式，其实大家多多少少都听说过一些，比如单例模式、工厂模式等等随口就能说出来，但是要我说出具体的细节，或者用代码实现一遍，可能就不知道从何处着手了。所以特意系统的学习一下设计模式，以下就是我的一些学习笔记，如有错误，请不吝指出。 什么是设计模式？ 设计模式其实就是程序员在编程时总结出来的一系列模式、规则，是对软件设计中普遍存在（反复出现）的问题，所提出的解决方案。 设计模式包含了面向对象的精髓，”懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的核心”. 设计模式的目的 代码重用性、可读性、可扩展性、可靠性、高内聚低耦合… 设计模式的七大原则 单一职责原则 接口隔离原则 依赖倒转（倒置）原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 1）单一职责原则对类来说的，即一个类应该只负责一项职责。 2）接口隔离原则客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 3）依赖倒转原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象； 抽象不应该依赖细节，细节应该依赖抽象； 依赖倒转的中心思想是面向接口编程； 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 4）里氏替换原则 在使用继承的时候，遵循里氏替换原则，在子类中尽量不要重写父类的方法； 可以通过聚合、组合来解决问题。 注：聚合关系是整体和部分的关系，整体和部分可以分开（如：电脑由显示器、键盘、鼠标等组成，可以相互分离开）；组合关系也是整体和部分的关系，整体和部分不可以分开（如桌子是有桌子腿和桌面组成，但是他们不能分离开，分开就不是桌子了） 5）开闭原则（OCP） 是编程中最基础、最重要的设计原则 对扩展开放(对提供方)，对修改关闭(对使用方) 6）迪米特法则 一个对象应该对其他对象保持最少的了解 类与类关系越密切，耦合度越大 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好 只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象有耦合关系，就说这两个对象之间是朋友关系。耦合的方式有很多：依赖、关联、组合、聚合。其中，称出现成员变量、方法参数、返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友。 7）合成复用原则尽量使用合成/聚成的方式，而不是使用继承","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-02T15:59:36.176Z","updated":"2020-01-02T15:59:36.176Z","comments":true,"path":"2020/01/02/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}