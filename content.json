{"meta":{"title":"Tang's blog","subtitle":"coding、writing、fighting","description":"Coding change world~","author":"Tang Jian","url":"http://www.tangjian.vip","root":"/"},"pages":[{"title":"分类","date":"2020-03-03T14:04:17.000Z","updated":"2020-03-03T14:09:04.214Z","comments":true,"path":"categories/index.html","permalink":"http://www.tangjian.vip/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-03T14:06:47.000Z","updated":"2020-03-03T14:07:46.937Z","comments":true,"path":"tags/index.html","permalink":"http://www.tangjian.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java设计模式学习笔记六","slug":"Java设计模式学习笔记六","date":"2020-04-19T02:24:06.000Z","updated":"2020-04-19T15:28:10.751Z","comments":true,"path":"2020/04/19/Java设计模式学习笔记六/","link":"","permalink":"http://www.tangjian.vip/2020/04/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/","excerpt":"适配器模式1、基本介绍 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper） 适配器模式属于结构型模式 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式 2、工作原理 适配器模式：讲一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容 从用户的角度看不到被适配者，是解耦的 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法 用户收到反馈结果，感觉只是和目标接口交互 类适配器模式基本介绍：Adapter类、通过继承src类，实现dest类接口，完成 src——&gt;dst 的适配。 注意事项和细节： Java是单继承，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是一个接口，有一定局限性 src类的方法在 Adapter 中都会暴露出来，也增加了使用的成本 由于其继承了src类，所以它可以根据需求重写src类的方法，使得 Adapter 的灵活性增强了","text":"适配器模式1、基本介绍 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器（Wrapper） 适配器模式属于结构型模式 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式 2、工作原理 适配器模式：讲一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容 从用户的角度看不到被适配者，是解耦的 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法 用户收到反馈结果，感觉只是和目标接口交互 类适配器模式基本介绍：Adapter类、通过继承src类，实现dest类接口，完成 src——&gt;dst 的适配。 注意事项和细节： Java是单继承，所以类适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是一个接口，有一定局限性 src类的方法在 Adapter 中都会暴露出来，也增加了使用的成本 由于其继承了src类，所以它可以根据需求重写src类的方法，使得 Adapter 的灵活性增强了 对象适配器模式 根据“合成复用原则”，在系统中尽量使用关联关系（聚合）来代替继承关系 接口适配器模式 核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择低覆盖父类的某些方法来实现需求 适配器模式应用 SpringMvc 中的 HandlerAdapter ，就使用了适配器模式 适配器模式的注意事项和细节 三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在Adapter 里的形式）来命名的 三类适配器 类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承 对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有 接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现 Adapter 模式最大的作用还是将原来不兼容的接口融合在一起 实际开发中，实现起来不拘泥于我们讲解的三种经典形式","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记五","slug":"Java设计模式学习笔记五","date":"2020-04-04T07:40:07.000Z","updated":"2020-04-04T15:34:48.093Z","comments":true,"path":"2020/04/04/Java设计模式学习笔记五/","link":"","permalink":"http://www.tangjian.vip/2020/04/04/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/","excerpt":"建造者模式 基本介绍 建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节。 建造者模式的四个角色 Product（产品角色）：一个具体的产品对象 Builder（抽象建造者）：创建一个Product 对象的各个部件指定的接口/抽象类 ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。 Director（指挥官）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。主要有两个合作用户，一是：隔离了客户与对象的生产过程。二是：负责控制产品对象的生产过程","text":"建造者模式 基本介绍 建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部的具体构建细节。 建造者模式的四个角色 Product（产品角色）：一个具体的产品对象 Builder（抽象建造者）：创建一个Product 对象的各个部件指定的接口/抽象类 ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。 Director（指挥官）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。主要有两个合作用户，一是：隔离了客户与对象的生产过程。二是：负责控制产品对象的生产过程 原理类图 代码实现 1234567891011121314151617181920212223242526272829303132/** * 产品(房子) */public class House &#123; private String baise; private String wall; private String roofed; public String getBaise() &#123; return baise; &#125; public void setBaise(String baise) &#123; this.baise = baise; &#125; public String getWall() &#123; return wall; &#125; public void setWall(String wall) &#123; this.wall = wall; &#125; public String getRoofed() &#123; return roofed; &#125; public void setRoofed(String roofed) &#123; this.roofed = roofed; &#125;&#125; 12345678910111213141516/** * 抽象的建造者 */public abstract class HouseBuilder &#123; protected House house = new House(); //建造流程，抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); //建造好房子，将产品（房子）返回 public House buildHouse() &#123; return house; &#125;&#125; 12345678910111213141516171819202122/** * 指挥者，去指定建造流程，返回产品 */public class HouseDirector &#123; HouseBuilder houseBuilder = null; public HouseDirector(HouseBuilder houseBuilder)&#123; this.houseBuilder = houseBuilder; &#125; public void setHouseBuilder(HouseBuilder houseBuilder) &#123; this.houseBuilder = houseBuilder; &#125; //如何构建房子，处理过程交给指挥官 public House constructHouse()&#123; houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); &#125;&#125; 12345678910111213141516171819/** * 具体建造者（普通房子） */public class CommonHouse extends HouseBuilder &#123; @Override public void buildBasic() &#123; System.out.println(\"普通房子打地基5米\"); &#125; @Override public void buildWalls() &#123; System.out.println(\"普通房子砌墙10cm\"); &#125; @Override public void roofed() &#123; System.out.println(\"普通房子封顶\"); &#125;&#125; 12345678910111213141516171819/** * 具体建造者（高楼） */public class HighHouse extends HouseBuilder &#123; @Override public void buildBasic() &#123; System.out.println(\"高楼打地基100米\"); &#125; @Override public void buildWalls() &#123; System.out.println(\"高楼砌墙20cm\"); &#125; @Override public void roofed() &#123; System.out.println(\"高楼封顶\"); &#125;&#125; 123456789101112131415161718public class Client &#123; public static void main(String[] args) &#123; //盖普通房子 CommonHouse commonHouse = new CommonHouse(); //准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); //完成盖房子，返回产品（普通房子） House house = houseDirector.constructHouse(); System.out.println(\"=============================\"); //盖高楼 HighHouse highHouse = new HighHouse(); houseDirector.setHouseBuilder(highHouse); houseDirector.constructHouse(); &#125;&#125; 在JDK源码中的应用 java.lang.StringBuilder 中的建造者模式 建造者模式的注意事项和细节 客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类变成，系统扩展方便，符合”开闭原则“ 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围收到一点过的限制 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式 抽象工厂模式 VS 建造者模式 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关系构建过程，只关心产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是要通过组装零配件而产生一个新产品。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记四","slug":"Java设计模式学习笔记四","date":"2020-03-29T01:22:32.000Z","updated":"2020-03-29T13:31:12.264Z","comments":true,"path":"2020/03/29/Java设计模式学习笔记四/","link":"","permalink":"http://www.tangjian.vip/2020/03/29/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/","excerpt":"原型模式 克隆羊的问题 现在有一只羊 tom，name = tom，age=1，color=white 传统方式解决克隆羊问题 1234567public class Sheep &#123; private String name; private int age; private String color; ...//省略了get/set方法以及构造器方法&#125; 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; Sheep sheep = new Sheep( \"tom\",1, \"white\"); Sheep sheep1 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); System.out.println(sheep); System.out.println(sheep1); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); &#125;&#125; 传统方式的优缺点","text":"原型模式 克隆羊的问题 现在有一只羊 tom，name = tom，age=1，color=white 传统方式解决克隆羊问题 1234567public class Sheep &#123; private String name; private int age; private String color; ...//省略了get/set方法以及构造器方法&#125; 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; Sheep sheep = new Sheep( \"tom\",1, \"white\"); Sheep sheep1 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); System.out.println(sheep); System.out.println(sheep1); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); &#125;&#125; 传统方式的优缺点 优点：简单易懂易操作 缺点： 在创建新对象的时候，总事需要重新获取原始对象的属性，如果创建对象比较复杂时，效率低 总是需要重新初始化对象，而不是动态的获取对象运行时状态，不灵活 改进思路： Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口 Cloneable，该接口表示该类能够复制且有复制的能力==》原型模式 原型模式——基本介绍 原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型设计模式，允许一个对象在创建另一个可定制的对象，无需知道如何创建的细节 工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象clone() 原型模式解决克隆羊问题–代码实现 12345678910111213141516public class Sheep implements Cloneable&#123; private String name; private int age; private String color; ... //省略了get/set方法以及构造器方法 @Override protected Object clone() &#123; Sheep sheep = null; try &#123; sheep = (Sheep)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return sheep; &#125;&#125; 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; System.out.println(\"原型模式完成对象的创建克隆\"); Sheep sheep = new Sheep( \"tom\",1, \"white\"); Sheep sheep1 = (Sheep)sheep.clone(); Sheep sheep2 = (Sheep)sheep.clone(); Sheep sheep3 = (Sheep)sheep.clone(); Sheep sheep4 = (Sheep)sheep.clone(); System.out.println(sheep); System.out.println(sheep1); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); &#125;&#125; 原型模式在Spring框架中的应用 Spring 中原型 bean 的创建，就是原型模式的应用 深拷贝-浅拷贝 7.1 浅拷贝 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象 对于数据类型是引用数据类型的成员变量，那么浅拷贝进行引用传递，也就是只是将该成员变量的引用之（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。 上面所展示的克隆羊是浅拷贝 浅拷贝是使用默认的 clone() 方法来实现：sheep = (Sheep)super.clone(); 7.2 深拷贝 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝 深拷贝实现方式1：重写 clone 方法来实现深拷贝 深拷贝实现方式2：通过对象序列化实现深拷贝（推荐使用） 原型模式的注意事项和细节 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程 ，同时也能够提高效率。 不用重新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码 在实现深克隆的时候可能需要比较复杂的代码 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但是已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记三","slug":"Java设计模式学习笔记三","date":"2020-03-08T13:35:17.000Z","updated":"2020-03-18T14:54:34.023Z","comments":true,"path":"2020/03/08/Java设计模式学习笔记三/","link":"","permalink":"http://www.tangjian.vip/2020/03/08/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/","excerpt":"工厂模式简单工厂模式（不属于23种设计模式之一） 属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式； 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为； 使用场景：在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 例子： 12345678/** * 运算类：有一个抽象方法 */public abstract class Operation &#123; public double number1; public double number2; public abstract double result();&#125;","text":"工厂模式简单工厂模式（不属于23种设计模式之一） 属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式； 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为； 使用场景：在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 例子： 12345678/** * 运算类：有一个抽象方法 */public abstract class Operation &#123; public double number1; public double number2; public abstract double result();&#125; 123456789/** * 加法类，继承运算类并且重写父类方法 */public class OperationAdd extends Operation &#123; @Override public double result() &#123; return number1 + number2; &#125;&#125; 123456789/** * 减法类，继承运算类并且重写父类方法 */public class OperationSub extends Operation &#123; @Override public double result() &#123; return number1 - number2; &#125;&#125; 12345678910111213141516171819/** * 创建一个简单工厂 */public class OpreationFactory &#123; public static Operation createOperate(String operate)&#123; Operation operation = null; switch (operate)&#123; case \"+\": operation = new OperationAdd(); break; case \"-\": operation = new OperationSub(); break; default: System.out.println(\"您输入的运算符有误!\"); &#125; return operation; &#125;&#125; 1234567891011121314/** * 测试类 */public class Calculator &#123; public static void main(String[] args) &#123; Operation operation; String operator; operator = \"-\"; operation = OpreationFactory.createOperate(operator); operation.number1 = 10; operation.number2 = 8; System.out.println(operation.result()); &#125;&#125; 优缺点： 优点：简单易懂 缺点：违背了开闭原则 工厂方法模式 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。 例子：还是上面的运算例子，如果需要添加一个乘法运算的话，除了要添加一个乘法类继承运算类，还需要修改工厂代码添加一个判断，所以简单工厂模式违背了开闭原则。使用工厂模式的话只需要添加一个乘法类继承运算类以及添加一个乘法工厂实现工厂接口就可以了，完美的遵循开闭原则，代码如下： 123456/** * 工厂方法 */public interface IFactory &#123; Operation createOperation();&#125; 1234567891011121314151617181920212223242526272829/*** 加法工厂，实现了工厂方法接口*/public class AddFactory implements IFactory &#123; @Override public Operation createOperation() &#123; return new OperationAdd(); //该类见上面简单工厂方法 &#125;&#125;/*** 减法工厂，实现了工厂方法接口*/public class SubFactory implements IFactory &#123; @Override public Operation createOperation() &#123; return new OperationSub(); //该类见上面简单工厂方法 &#125;&#125;/*** 乘法工厂，实现了工厂方法接口*/public class MultiFactory implements IFactory &#123; @Override public Operation createOperation() &#123; return new OperationMulti(); &#125;&#125; 123456789/** * 乘法类，继承运算类并且重写父类方法 */public class OperationMulti extends Operation&#123; @Override public double result() &#123; return number1 * number2; &#125;&#125; 12345678910111213/** * 测试类 */public class Calculator &#123; public static void main(String[] args) &#123; Operation operation; IFactory factory = new MultiFactory(); operation = factory.createOperation(); operation.number1 = 2; operation.number2 = 3; System.out.println(operation.result()); &#125;&#125; 优缺点： 优点：遵循了开闭原则 缺点：类的个数容易过多，增加了系统的复杂度 抽象工厂模式 抽象工厂模式：定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类。 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者进一步的抽象）。 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。 优缺点： 优点：遵循开闭原则，可以生产一个产品体系。 缺点：如果要添加一个产品类，就得增加很多代码 工厂模式在JDK中的应用 JDK中，Calendar类就是使用的简单工厂模式 总结 工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦，从而提高了项目的扩展性和维护性。 三种工厂模式（简单工厂模式、工厂模式、抽象工厂模式）的区别： 简单工厂模式：不符合开闭原则，只有一个具体的工厂类，当需要增加一个产品时，需要修改工厂代码 工厂模式：符合开闭原则，只有一个抽象的产品类，只能生产单一产品。 抽象工厂模式：符合开闭原则，有多个抽象产品类，能生产一个产品体系 设计模式的依赖抽象原则 创建对象实例时，不要直接 new 类，而是把这个 new 类的动作放在一个工厂方法中，并返回； 不要让类继承具体类，而是继承抽象类或者是实现接口； 不要覆盖基类中已经实现的方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记二","slug":"Java设计模式学习笔记二","date":"2020-03-06T14:09:04.000Z","updated":"2020-03-15T13:54:19.272Z","comments":true,"path":"2020/03/06/Java设计模式学习笔记二/","link":"","permalink":"http://www.tangjian.vip/2020/03/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/","excerpt":"Java设计模式一般分为三类：创建型、结构型、行为型 共有23种 创建型模式（5个）：单例模式、抽象工厂模式、工厂模式、原型模式、建造者模式 结构型模式（7个）：适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式、代理模式 行为型模式（11个）：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式） 注：各个地方出现的名称可能略有不同（翻译问题） 单例模式 单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法（静态方法）。 单例模式有八种实现方法 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举","text":"Java设计模式一般分为三类：创建型、结构型、行为型 共有23种 创建型模式（5个）：单例模式、抽象工厂模式、工厂模式、原型模式、建造者模式 结构型模式（7个）：适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式、代理模式 行为型模式（11个）：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式） 注：各个地方出现的名称可能略有不同（翻译问题） 单例模式 单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法（静态方法）。 单例模式有八种实现方法 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举 1）饿汉式（静态常量） 构造器私有化（防止 new） 类的内部创建对象 向外暴露一个静态的公共方法。getInstance() 代码实现 123456789101112class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private final static Singleton instance = new Singleton(); //3.提供静态公共方法，返回实例对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 优缺点： 优点：简单，在类装载的时候就完成实例化。避免了线程同步的问题。 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。容易造成内存浪费（可能这个实例从始至终未曾使用过） 2）饿汉式（静态代码块） 代码实现 123456789101112131415class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; static &#123; instance = new Singleton(); &#125; //3.提供静态公共方法，返回实例对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 优缺点： 这种方法和上面的方法类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。所以优缺点和上面方法是一样的。 3）懒汉式（线程不安全） 构造器私有化 类的内部创建对象实例 提供一个静态的公共方法，当使用到该方法时，采取创建实例 代码实现 12345678910111213141516class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; //3.提供一个静态的公共方法，当使用到该方法时，才去创建实例（需要了才去行动叫懒汉式） public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 优缺点： 优点：起到了 Lazy Loading 的效果，不会造成内存的浪费 只能在单线程下使用，如果多线程下，一个线程进入了 if 判断语句，还未来得及往下执行，另一个线程也通过了这个 if 判断语句，这时便会产生多个实例。 4）懒汉式（线程安全，同步方法） 代码实现 123456789101112131415class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; //3.提供一个静态的公共方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优缺点： 优点：解决了线程安全问题 缺点：效率太低，每次获取实例的时候都要进行同步操作，同步效率太低。 5）懒汉式（同步代码块） 代码实现 123456789101112131415class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public static Singleton getInstance()&#123; if(instance == null) &#123; synchronized (Singleton.class) &#123;//同步代码块 instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 优缺点：同上（同步方法） 6）双重检查 懒汉式+同步方法+同步代码块 代码实现 1234567891011121314151617class Singleton&#123; private Singleton()&#123;&#125; //使用volatile关键字会强制将修改的值立即写入主存； private static volatile Singleton instance; public static synchronized Singleton getInstance()&#123;//同步方法 if(instance == null)&#123; synchronized(Singleton.class)&#123;//同步代码块 if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优缺点： 优点：保证线程安全，延迟加载，效率较高（实例化代码只用执行一次） 缺点：代码相对较复杂，需要两次 if 检查 推荐使用该种单例设计模式 7）静态内部类 代码实现 12345678910111213141516class Singleton&#123; //构造器私有化 private Singleton()&#123;&#125; private static volatile Singleton instance; //静态内部类，该类中有一个静态属性 Singleton private static class SingletonInstance &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //提供一个静态的公共方法，直接返回 SingletonInstance.INSTANCE public static synchronized Singleton getInstance()&#123; return SingletonInstance.INSTANCE; &#125;&#125; 优缺点： 优点：保证线程安全，延迟加载，效率高 推荐使用 8）枚举 代码实现 123enum Singleton&#123; INSTANCE; //属性&#125; 优缺点： 优点：线程安全，能防止反序列化重新创建新对象 推荐使用 单例模式在 JDK 中的应用 JDK中，java.lang.Runtime 就是经典的单例模式（饿汉式） 注 单例模式保证了系统内存中只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 当实例化一个单例类的时候，必须要记住使用 相应的获取对象的方法如：getInstance()，而不是去 new 单例模式使用场景：需要频繁进行创建和销毁对象、创建对象时耗时过多或耗费资源过度（重量级对象），但又经常要用到的对象、工具类对象、频繁访问数据库或文件的对象（如：数据源、session工厂）","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记","slug":"Java设计模式学习笔记","date":"2020-03-03T13:51:20.000Z","updated":"2020-03-12T15:04:32.319Z","comments":true,"path":"2020/03/03/Java设计模式学习笔记/","link":"","permalink":"http://www.tangjian.vip/2020/03/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"谈起设计模式，其实大家多多少少都听说过一些，比如单例模式、工厂模式等等随口就能说出来，但是要我说出具体的细节，或者用代码实现一遍，可能就不知道从何处着手了。所以特意系统的学习一下设计模式，以下就是我的一些学习笔记，如有错误，请不吝指出。 什么是设计模式？ 设计模式其实就是程序员在编程时总结出来的一系列模式、规则，是对软件设计中普遍存在（反复出现）的问题，所提出的解决方案。 设计模式包含了面向对象的精髓，”懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的核心”. 设计模式的目的 代码重用性、可读性、可扩展性、可靠性、高内聚低耦合… 设计模式的七大原则 单一职责原则 接口隔离原则 依赖倒转（倒置）原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则","text":"谈起设计模式，其实大家多多少少都听说过一些，比如单例模式、工厂模式等等随口就能说出来，但是要我说出具体的细节，或者用代码实现一遍，可能就不知道从何处着手了。所以特意系统的学习一下设计模式，以下就是我的一些学习笔记，如有错误，请不吝指出。 什么是设计模式？ 设计模式其实就是程序员在编程时总结出来的一系列模式、规则，是对软件设计中普遍存在（反复出现）的问题，所提出的解决方案。 设计模式包含了面向对象的精髓，”懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的核心”. 设计模式的目的 代码重用性、可读性、可扩展性、可靠性、高内聚低耦合… 设计模式的七大原则 单一职责原则 接口隔离原则 依赖倒转（倒置）原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 1）单一职责原则对类来说的，即一个类应该只负责一项职责。 2）接口隔离原则客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 3）依赖倒转原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象； 抽象不应该依赖细节，细节应该依赖抽象； 依赖倒转的中心思想是面向接口编程； 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 4）里氏替换原则 在使用继承的时候，遵循里氏替换原则，在子类中尽量不要重写父类的方法； 可以通过聚合、组合来解决问题。 注：聚合关系是整体和部分的关系，整体和部分可以分开（如：电脑由显示器、键盘、鼠标等组成，可以相互分离开）；组合关系也是整体和部分的关系，整体和部分不可以分开（如桌子是有桌子腿和桌面组成，但是他们不能分离开，分开就不是桌子了） 5）开闭原则（OCP） 是编程中最基础、最重要的设计原则 对扩展开放(对提供方)，对修改关闭(对使用方) 6）迪米特法则 一个对象应该对其他对象保持最少的了解 类与类关系越密切，耦合度越大 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好 只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象有耦合关系，就说这两个对象之间是朋友关系。耦合的方式有很多：依赖、关联、组合、聚合。其中，称出现成员变量、方法参数、返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友。 7）合成复用原则尽量使用合成/聚成的方式，而不是使用继承","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"JVM学习笔记","slug":"JVM学习笔记 ","date":"2020-03-03T13:51:20.000Z","updated":"2021-03-07T09:47:20.349Z","comments":true,"path":"2020/03/03/JVM学习笔记 /","link":"","permalink":"http://www.tangjian.vip/2020/03/03/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20/","excerpt":"","text":"JVM是什么定义:JVM是Java Virtual Machine（Java虚拟机）的缩写，是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制。 可以将JVM理解为是一个运行字节码的平台。 作用： 提供Java的运行环境 加载代码、验证代码、执行代码 垃圾回收 为什么要学习JVM 首先，作为一名Java程序员，通过学习JVM，能让你对Java这门语言有更深刻的理解，更加了解底层程序的执行过程； 其次，我们都知道Java语言，是一个能自动回收内存的语言，这个特点大大方便了我们程序员。但是，也正因为这个特点，如果程序发生内存泄漏、内存溢出等情况的时候，而我们又不了解底层的垃圾回收机制的话，就会给我们解决问题带来很大的麻烦。 进入正题JVM架构图-简图 JVM家族鼻祖：Sun Classic、Exact VM 主流：HotSpot VM 次之：BEA JRockit、IBM J9 VM 其他：BEA Liquid VM、Azul VM… 类加载器子系统作用 类加载子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的标识。 ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎来决定。 类加载过程 加载——&gt;链接——&gt;初始化——&gt;使用——&gt;卸载 链接包括三个阶段（验证、准备、解析） 类加载器分类 启动类加载器（Bootstrap ClassLoader） 扩展类加载器（Extension ClassLoader） 系统类加载器（Application ClassLoader） 自定义类加载器（User Defined ClassLoader） 类加载机制双亲委派机制 定义： 当一个类加载器收到了类加载的请求时，它首先不会自己去加载，而是会把这个请求交给父类加载器，如果父类加载器还有父类，就会一直往上传，直至传递到启动类加载器，如果父类加载器不能加载，才由子类加载器进行加载。 好处： 避免类重复加载 保护程序安全，防止核心API被随意修改 自定义类：java.lang.String（该类不会被加载） 自定义类：java.lang.Tang（报错：阻止创建 java.lang开头的类） 保证核心API的访问权限 内存模型（运行时数据区） 运行时数据区是JVM中非常重要的一部分，由程序计数器、虚拟机栈、本地方法栈、堆、方法区组成。 程序计数器（Program Counter Register）介绍JVM中的程序计数寄存器（Program Counter Register）中，Register的命名起源于CPU的寄存器，寄存器存储指令相关的现场信息。 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法时，则是未指定值（undefined）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 它是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。 作用程序计数器用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令。 虚拟机栈（Stack）概述Java虚拟机栈是线程私有的，用于存储栈帧。每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等。每一个方法从调用直至方法执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈。 作用主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。 栈中发生的异常有StackOverflowError、OutOfMemoryError 如果线程请求分配的栈容量超过虚拟机栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。 如果虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出一个outofMemoryError异常。12345678// 演示栈中的异常：StackOverflowErrorpublic class StackErrorTest &#123; private static int count = 1; public static void main(String[] args) &#123; System.out.println(count++); main(args); &#125;&#125; 设置栈内存大小我们可以使用参数 -Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度 -Xss256k 本地方法栈（Native Method Stack）概述本地方法栈与虚拟机栈类似，唯一的区别就是：Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。 注：本地方法是使用C语言实现的 堆（Heap）概述堆是线程共享的。用于存放对象实例，几乎所有的对象实例都在这里分配内存。堆也是Java内存管理的核心区域，所以有时候也称之为 ”GC堆“。 设置堆内存大小堆内存的大小是可以调节的，通过-Xms、-Xmx参数来设置 -Xms20m -Xmx20m （表示最小内存20兆，最大内存20兆）通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。 默认情况下 初始内存大小：物理电脑内存大小/64 最大内存大小：物理电脑内存大小/4 如何查看堆内存的内存分配情况 -> jstat -gc 进程id```123&#96;&#96;&#96;&#x2F;&#x2F; 或者在程序运行时，通过配置运行参数-XX:+PrintGCDetails 堆内存细分Java7及之前堆内存逻辑上分为三部分：新生区（Young/New）+养老区（Old/Tenure）+永久区（Permanent Space） Java8及之后堆内存逻辑上分为三部分：新生区（Young/New）+养老区（Old/Tenure）+元空间（Meta Space） 新生区又被划分为Eden区和Survivor区（From 和 To） Eden：From：To -&gt; 6 : 1 : 1 新生区：老年区 - &gt; 1 : 2 可通过参数配置各区在堆结构中的占比： 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 -xx:SurvivorRatio=8，表示Eden空间和另外两个survivor空间所占的比例是8：1：1 当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优 几乎所有的Java对象都是在Eden区被new出来的。 绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代） IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。 可以使用选项”-Xmn”设置新生代最大内存大小（一般不使用） 可以设置参数：-Xx:MaxTenuringThreshold= N 进行设置新生代进入老年代的年龄 堆空间相关的参数设置 -XX：+PrintFlagsInitial：查看所有的参数的默认初始值 -XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值） -Xms：初始堆空间内存（默认为物理内存的1/46） -Xmx：最大堆空间内存（默认为物理内存的1/4） -Xmn：设置新生代的大小（初始值及最大值） -XX:NewRatio：配置新生代与老年代在对结构的占比 -XX:SurvivorRatio：设置新生代中Eden和S0和S1空间的占比 -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄 -XX: +PrintGCDetails：输出详细的GC处理日志 打印gc简要信息：①-Xx: +PrintGC ② -verbose:gc -XX:HandlePromotionFailure：是否设置空间分配担保 图解YGC过程我们创建的对象，一般都是存放在Eden区，当Eden区满了之后，就会触发GC操作，这个操作一般会称为YGC/Minor GC. 我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中 对象分配-图解 代码演示对象分配过程 123456789101112131415/** * 内存分配过程演示 * 设置内存大小：-Xms600m -Xmx600m * 通过 jvisualvm 查看内存分布 */public class HeapInstanceTest &#123; byte[] buffer = new byte[1024 * 200]; public static void main(String[] args) throws InterruptedException &#123; ArrayList&lt;HeapInstanceTest&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new HeapInstanceTest()); Thread.sleep(10); &#125; &#125;&#125; 方法区（Method Area）概述：是线程共享的，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。 方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象。 方法区与Java堆一样，是各个线程共享的内存区域 方法区在JVM启动的时候创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutofMemoryError:PermGen space 或者java.lang.OutOfMemoryError:Metaspace 加载大量的第三方的jar包 Tomcat部署的工程过多（30~50个） 大量动态的生成反射类 关闭JVM就会释放这个区域的内存 方法区的演进 首先只有HotSpot才有永久代 jdk版本 变化 jdk1.6及之前 有永久代（permanent generation），静态变量存放在永久代上 jdk1.7 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中 jdk1.8及之后 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存 永久代、元空间二者并不只是名字变了，内部结构也调整了 永久代为什么要被元空间替代？ 为永久代设置空间大小很难确定的（而元空间在本地内存中，没有这个问题） 对永久代进行调优是很困难的（方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型） 垃圾回收（GC） 什么是垃圾？ 为什么要垃圾回收？ Java垃圾回收机制 什么是垃圾垃圾是指在运行程序中没有任何指向的对象，这个对象就是需要被回收的垃圾。 为什么需要垃圾回收如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间就会一直保留到应用程序的结束，被保留的空间无法被其他对象使用，久而久之就会导致内存溢出。 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。 Java垃圾回收特点优点 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险 自动内存管理，将程序员从繁重的内存管理中释放出来，可以更专注于业务开发。 担忧 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于”自动“，那么最严重的情况就是会弱化Java开发人员在程序出现内存溢出时，定位问题和解决问题的能力。此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有真正了解JVM是如何管理内存后，我们才能在遇见OOM时，快速地根据错误日志定位问题和解决问题。 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 垃圾回收相关算法在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。 那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。 判断对象存活一般有两种方式：引用计数算法和可达性分析算法。 标记阶段：引用计数算法引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。 缺点：a.它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。b.每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。c.引用计数器还有一个严重问题，即无法处理循环引用的情况。这是一条致命的缺陷，导致在Java的垃圾回收器中没有使用这类标记方法。 循环引用 当Obj1对象的指针断开的时候，内部的引用形成一个循环，这就是循环引用，从而造成内存泄漏。 12345678910111213141516171819/** * 引用计数算法测试 * 运行时参数：-XX:+PrintGCDetails */public class RefCountGC &#123; // 引用 Object reference = null; public static void main(String[] args) &#123; RefCountGC obj1 = new RefCountGC(); RefCountGC obj2 = new RefCountGC(); obj1.reference = obj2; obj2.reference = obj1; obj1 = null; obj2 = null; // 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？ System.gc(); &#125;&#125; 标记阶段：可达性分析算法概述可达性分析算法：也可称为根搜索算法、追踪性垃圾收集（Tracing Garbage Collection）算法 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。 基本思路 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain） 如果目标对象没有任何引用链，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象。 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。 GC Roots可以是哪些？虚拟机栈引用的对象 比如：各个线程被调用的方法中使用到的参数、局部变量等。 本地方法栈内JNI（通常说的本地方法）引用的对象，方法区中类静态属性引用的对象 比如：Java类的引用类型静态变量 方法区中常量引用的对象 比如：字符串常量池（String Table）里的引用 所有被同步锁synchronized持有的对象 Java虚拟机内部的引用 基本数据类型对应的Class对象，一些常驻的异常对象（如NullPointerException、OutOfMemoryError），系统类加载器。 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是： 标记-清除算法（Mark-Sweep） 复制算法（Copying） 标记-整理算法（Mark-Compact） 清除阶段：标记-清除算法标记清除算法是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy等人在1960年提出并应用于Lisp语言。 执行过程 当堆中的有效内存空间被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项是标记，第二项则是清除。 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 标记的是引用的对象，不是垃圾！！ 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收 什么是清除？ 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。 关于空闲列表： 如果内存规整 采用指针碰撞的方式进行内存分配 如果内存不规整 虚拟机需要维护一个列表 空闲列表分配 缺点 标记清除算法的效率不算高 在进行GC的时候，需要停止整个应用程序，用户体验差 这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表 清除阶段：复制算法背景 为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky在1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器”。M.L.Minsky在该论文中描述的算法被人们称为复制算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。 核心思想 将活着的内存空间分为两块，每次只是用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。 把可达的对象，直接复制到另外一个区域中复制完成后，A区就没有用了，里面的对象可以直接清除掉，其实堆中的的新生代就用到了复制算法 优点 没有标记和清除过程，实现简单，运行高效 复制过去以后保证空间的连续性，不会出现“碎片”问题 缺点 此算法的缺点也是很明显的，就是需要两倍的内存空间（或者说内存浪费严重） 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小 注意 如果系统中的垃圾对象很多，复制算法不是很理想。因为复制算法需要复制的存活对象数量不能太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率就会很低） 应用场景 在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。 清除阶段：标记-整理算法（也叫标记-压缩算法）背景 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象，如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。 标记-清除算法的确可以应用在老年代，但是该算法不仅执行效率低下，而且在执行玩内存回收后还会产生内存碎片，所以JVM的设计者需要再次基础上进行改进。标记-压缩算法由此诞生。 1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-整理算法。在许多现代的垃圾收集器中，人们都使用了标记-整理算法或其改进版本。 执行过程 第一阶段和标记清除算法一样，从根节点开始标记所有被引用的对象 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。 标记清除和标记整理的区别 标记-整理算法的最终效果等同于标记-清除算法执行完成之后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-整理算法。 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-整理是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象会被整理，按照内存地址依次排列，而未标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记-整理的优缺点 优点 消除了标记-清除算法当中，内存区域分散的缺点，没有碎片的问题，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。 消除了复制算法当中，内存减半的高额代价。 缺点 从效率上来说，标记-整理算法要低于复制算法 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址 移动过程中，需要全程暂停用户应用程序。即：STW 小结效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。 而综合来看，标记-整理算法相对来说更好一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。 标记清除 标记整理 复制 速率 中等 最慢 最快 空间开销 少（但会堆积碎片） 少（不堆积碎片） 通常需要活对象的2倍空间（不堆积碎片） 移动对象 否 是 是 ps：没有最好的算法，只有最合适的算法 垃圾回收器垃圾收集器分类 按线程数分：串行垃圾回收器和并行垃圾回收器 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。 在诸如单CPU或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中。 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。 和串行相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。 按工作模式分：并发式垃圾回收器和独占式垃圾回收器 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。 独占式垃圾回收器一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。 按碎片处理方式分：压缩式垃圾回收器和非压缩式垃圾回收器 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片 非压缩式的垃圾回收器不进行这步操作 按工作的内存空间分：年轻代垃圾回收器和老年代垃圾回收器不同的垃圾回收器概述垃圾收集机制是Java的招牌能力，极大地提高了开发效率。 那么，Java常见的垃圾收集器有哪些？ 垃圾回收器发展史有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。 1999年随JDK1.3.1一起来的是串行方式的serialGC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本 2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布· Parallel GC在JDK6之后成为HotSpot默认GC。 2012年，在JDK1.7u4版本中，G1可用。 2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental） 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在mac os和Windows上的应用 7种经典的垃圾收集器 串行回收器：Serial、Serial Old 并行回收器：ParNew、Parallel Scavenge、Parallel Old 并发回收器：CMS、G1 两个收集器间有连线，表明他们可以搭配使用：Serial/Serial old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1； 其中Serial Old作为CMS出现失败“Concurrent Mode Failure”的后备预案 （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。 （绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366） （青色虚线）JDK14中：删除CMS垃圾回收器（JEP363） ps: jdk8默认的是 Parallel Scavenge/Parallel Old-XX:+PrintcommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器） 为什么要有很多收集器，一个不够吗？ 因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。 垃圾回收器总结7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。 GC发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC 怎么选择垃圾回收器Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？ 优先调整堆的大小让JVM自适应完成。 如果内存小于100M，使用串行收集器 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择 如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。 最后需要明确一个观点： 没有最好的收集器，更没有万能的收集器 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器 常见垃圾回收器组合参数设定：(1.8) -XX:+UseSerialGC = Serial New (DefNew) + Serial Old 小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器 -XX:+UseParNewGC = ParNew + SerialOld 这个组合已经很少用（在某些版本中已经废弃） https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future -XX:+UseConc(urrent)MarkSweepGC = ParNew + CMS + Serial Old -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】 -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old -XX:+UseG1GC = G1 Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC java +XX:+PrintCommandLineFlags -version 通过GC的日志来分辨 Linux下1.8版本默认的垃圾回收器到底是什么？ 1.8.0_181 默认（看不出来）Copy MarkCompact 1.8.0_222 默认 PS + PO 参考书籍：《深入理解Java虚拟机》","categories":[{"name":"Java JVM","slug":"Java-JVM","permalink":"http://www.tangjian.vip/categories/Java-JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.tangjian.vip/tags/JVM/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-02T15:59:36.176Z","updated":"2020-01-02T15:59:36.176Z","comments":true,"path":"2020/01/02/hello-world/","link":"","permalink":"http://www.tangjian.vip/2020/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}