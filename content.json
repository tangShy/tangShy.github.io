{"meta":{"title":"Tang's blog","subtitle":"coding、writing、fighting","description":"Coding change world~","author":"Tang Jian","url":"http://www.tangjian.vip","root":"/"},"pages":[{"title":"分类","date":"2020-03-03T14:04:17.000Z","updated":"2020-03-03T14:09:04.214Z","comments":true,"path":"categories/index.html","permalink":"http://www.tangjian.vip/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-03T14:06:47.000Z","updated":"2020-03-03T14:07:46.937Z","comments":true,"path":"tags/index.html","permalink":"http://www.tangjian.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java设计模式学习笔记四","slug":"Java设计模式学习笔记四","date":"2020-03-29T01:22:32.000Z","updated":"2020-03-29T13:31:12.264Z","comments":true,"path":"2020/03/29/Java设计模式学习笔记四/","link":"","permalink":"http://www.tangjian.vip/2020/03/29/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/","excerpt":"原型模式 克隆羊的问题 现在有一只羊 tom，name = tom，age=1，color=white 传统方式解决克隆羊问题 1234567public class Sheep &#123; private String name; private int age; private String color; ...//省略了get/set方法以及构造器方法&#125; 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; Sheep sheep = new Sheep( \"tom\",1, \"white\"); Sheep sheep1 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); System.out.println(sheep); System.out.println(sheep1); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); &#125;&#125; 传统方式的优缺点","text":"原型模式 克隆羊的问题 现在有一只羊 tom，name = tom，age=1，color=white 传统方式解决克隆羊问题 1234567public class Sheep &#123; private String name; private int age; private String color; ...//省略了get/set方法以及构造器方法&#125; 12345678910111213141516public class Client &#123; public static void main(String[] args) &#123; Sheep sheep = new Sheep( \"tom\",1, \"white\"); Sheep sheep1 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); Sheep sheep4 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); System.out.println(sheep); System.out.println(sheep1); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); &#125;&#125; 传统方式的优缺点 优点：简单易懂易操作 缺点： 在创建新对象的时候，总事需要重新获取原始对象的属性，如果创建对象比较复杂时，效率低 总是需要重新初始化对象，而不是动态的获取对象运行时状态，不灵活 改进思路： Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口 Cloneable，该接口表示该类能够复制且有复制的能力==》原型模式 原型模式——基本介绍 原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 原型模式是一种创建型设计模式，允许一个对象在创建另一个可定制的对象，无需知道如何创建的细节 工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象clone() 原型模式解决克隆羊问题–代码实现 12345678910111213141516public class Sheep implements Cloneable&#123; private String name; private int age; private String color; ... //省略了get/set方法以及构造器方法 @Override protected Object clone() &#123; Sheep sheep = null; try &#123; sheep = (Sheep)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return sheep; &#125;&#125; 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; System.out.println(\"原型模式完成对象的创建克隆\"); Sheep sheep = new Sheep( \"tom\",1, \"white\"); Sheep sheep1 = (Sheep)sheep.clone(); Sheep sheep2 = (Sheep)sheep.clone(); Sheep sheep3 = (Sheep)sheep.clone(); Sheep sheep4 = (Sheep)sheep.clone(); System.out.println(sheep); System.out.println(sheep1); System.out.println(sheep2); System.out.println(sheep3); System.out.println(sheep4); &#125;&#125; 原型模式在Spring框架中的应用 Spring 中原型 bean 的创建，就是原型模式的应用 深拷贝-浅拷贝 7.1 浅拷贝 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象 对于数据类型是引用数据类型的成员变量，那么浅拷贝进行引用传递，也就是只是将该成员变量的引用之（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。 上面所展示的克隆羊是浅拷贝 浅拷贝是使用默认的 clone() 方法来实现：sheep = (Sheep)super.clone(); 7.2 深拷贝 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝 深拷贝实现方式1：重写 clone 方法来实现深拷贝 深拷贝实现方式2：通过对象序列化实现深拷贝（推荐使用） 原型模式的注意事项和细节 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程 ，同时也能够提高效率。 不用重新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码 在实现深克隆的时候可能需要比较复杂的代码 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但是已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记三","slug":"Java设计模式学习笔记三","date":"2020-03-08T13:35:17.000Z","updated":"2020-03-18T14:54:34.023Z","comments":true,"path":"2020/03/08/Java设计模式学习笔记三/","link":"","permalink":"http://www.tangjian.vip/2020/03/08/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/","excerpt":"工厂模式简单工厂模式（不属于23种设计模式之一） 属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式； 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为； 使用场景：在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 例子： 12345678/** * 运算类：有一个抽象方法 */public abstract class Operation &#123; public double number1; public double number2; public abstract double result();&#125;","text":"工厂模式简单工厂模式（不属于23种设计模式之一） 属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式； 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为； 使用场景：在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 例子： 12345678/** * 运算类：有一个抽象方法 */public abstract class Operation &#123; public double number1; public double number2; public abstract double result();&#125; 123456789/** * 加法类，继承运算类并且重写父类方法 */public class OperationAdd extends Operation &#123; @Override public double result() &#123; return number1 + number2; &#125;&#125; 123456789/** * 减法类，继承运算类并且重写父类方法 */public class OperationSub extends Operation &#123; @Override public double result() &#123; return number1 - number2; &#125;&#125; 12345678910111213141516171819/** * 创建一个简单工厂 */public class OpreationFactory &#123; public static Operation createOperate(String operate)&#123; Operation operation = null; switch (operate)&#123; case \"+\": operation = new OperationAdd(); break; case \"-\": operation = new OperationSub(); break; default: System.out.println(\"您输入的运算符有误!\"); &#125; return operation; &#125;&#125; 1234567891011121314/** * 测试类 */public class Calculator &#123; public static void main(String[] args) &#123; Operation operation; String operator; operator = \"-\"; operation = OpreationFactory.createOperate(operator); operation.number1 = 10; operation.number2 = 8; System.out.println(operation.result()); &#125;&#125; 优缺点： 优点：简单易懂 缺点：违背了开闭原则 工厂方法模式 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。 例子：还是上面的运算例子，如果需要添加一个乘法运算的话，除了要添加一个乘法类继承运算类，还需要修改工厂代码添加一个判断，所以简单工厂模式违背了开闭原则。使用工厂模式的话只需要添加一个乘法类继承运算类以及添加一个乘法工厂实现工厂接口就可以了，完美的遵循开闭原则，代码如下： 123456/** * 工厂方法 */public interface IFactory &#123; Operation createOperation();&#125; 1234567891011121314151617181920212223242526272829/*** 加法工厂，实现了工厂方法接口*/public class AddFactory implements IFactory &#123; @Override public Operation createOperation() &#123; return new OperationAdd(); //该类见上面简单工厂方法 &#125;&#125;/*** 减法工厂，实现了工厂方法接口*/public class SubFactory implements IFactory &#123; @Override public Operation createOperation() &#123; return new OperationSub(); //该类见上面简单工厂方法 &#125;&#125;/*** 乘法工厂，实现了工厂方法接口*/public class MultiFactory implements IFactory &#123; @Override public Operation createOperation() &#123; return new OperationMulti(); &#125;&#125; 123456789/** * 乘法类，继承运算类并且重写父类方法 */public class OperationMulti extends Operation&#123; @Override public double result() &#123; return number1 * number2; &#125;&#125; 12345678910111213/** * 测试类 */public class Calculator &#123; public static void main(String[] args) &#123; Operation operation; IFactory factory = new MultiFactory(); operation = factory.createOperation(); operation.number1 = 2; operation.number2 = 3; System.out.println(operation.result()); &#125;&#125; 优缺点： 优点：遵循了开闭原则 缺点：类的个数容易过多，增加了系统的复杂度 抽象工厂模式 抽象工厂模式：定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类。 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者进一步的抽象）。 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。 优缺点： 优点：遵循开闭原则，可以生产一个产品体系。 缺点：如果要添加一个产品类，就得增加很多代码 工厂模式在JDK中的应用 JDK中，Calendar类就是使用的简单工厂模式 总结 工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦，从而提高了项目的扩展性和维护性。 三种工厂模式（简单工厂模式、工厂模式、抽象工厂模式）的区别： 简单工厂模式：不符合开闭原则，只有一个具体的工厂类，当需要增加一个产品时，需要修改工厂代码 工厂模式：符合开闭原则，只有一个抽象的产品类，只能生产单一产品。 抽象工厂模式：符合开闭原则，有多个抽象产品类，能生产一个产品体系 设计模式的依赖抽象原则 创建对象实例时，不要直接 new 类，而是把这个 new 类的动作放在一个工厂方法中，并返回； 不要让类继承具体类，而是继承抽象类或者是实现接口； 不要覆盖基类中已经实现的方法。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记二","slug":"Java设计模式学习笔记二","date":"2020-03-06T14:09:04.000Z","updated":"2020-03-15T13:54:19.272Z","comments":true,"path":"2020/03/06/Java设计模式学习笔记二/","link":"","permalink":"http://www.tangjian.vip/2020/03/06/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/","excerpt":"Java设计模式一般分为三类：创建型、结构型、行为型 共有23种 创建型模式（5个）：单例模式、抽象工厂模式、工厂模式、原型模式、建造者模式 结构型模式（7个）：适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式、代理模式 行为型模式（11个）：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式） 注：各个地方出现的名称可能略有不同（翻译问题） 单例模式 单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法（静态方法）。 单例模式有八种实现方法 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举","text":"Java设计模式一般分为三类：创建型、结构型、行为型 共有23种 创建型模式（5个）：单例模式、抽象工厂模式、工厂模式、原型模式、建造者模式 结构型模式（7个）：适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式、代理模式 行为型模式（11个）：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式） 注：各个地方出现的名称可能略有不同（翻译问题） 单例模式 单例模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得该对象实例的方法（静态方法）。 单例模式有八种实现方法 饿汉式（静态常量） 饿汉式（静态代码块） 懒汉式（线程不安全） 懒汉式（线程安全，同步方法） 懒汉式（线程安全，同步代码块） 双重检查 静态内部类 枚举 1）饿汉式（静态常量） 构造器私有化（防止 new） 类的内部创建对象 向外暴露一个静态的公共方法。getInstance() 代码实现 123456789101112class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private final static Singleton instance = new Singleton(); //3.提供静态公共方法，返回实例对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 优缺点： 优点：简单，在类装载的时候就完成实例化。避免了线程同步的问题。 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。容易造成内存浪费（可能这个实例从始至终未曾使用过） 2）饿汉式（静态代码块） 代码实现 123456789101112131415class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; static &#123; instance = new Singleton(); &#125; //3.提供静态公共方法，返回实例对象 public static Singleton getInstance()&#123; return instance; &#125;&#125; 优缺点： 这种方法和上面的方法类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。所以优缺点和上面方法是一样的。 3）懒汉式（线程不安全） 构造器私有化 类的内部创建对象实例 提供一个静态的公共方法，当使用到该方法时，采取创建实例 代码实现 12345678910111213141516class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; //3.提供一个静态的公共方法，当使用到该方法时，才去创建实例（需要了才去行动叫懒汉式） public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 优缺点： 优点：起到了 Lazy Loading 的效果，不会造成内存的浪费 只能在单线程下使用，如果多线程下，一个线程进入了 if 判断语句，还未来得及往下执行，另一个线程也通过了这个 if 判断语句，这时便会产生多个实例。 4）懒汉式（线程安全，同步方法） 代码实现 123456789101112131415class Singleton&#123; //1.构造器私有化 private Singleton()&#123;&#125; //2.类的内部创建对象实例 private static Singleton instance; //3.提供一个静态的公共方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优缺点： 优点：解决了线程安全问题 缺点：效率太低，每次获取实例的时候都要进行同步操作，同步效率太低。 5）懒汉式（同步代码块） 代码实现 123456789101112131415class Singleton&#123; private Singleton()&#123;&#125; private static Singleton instance; public static Singleton getInstance()&#123; if(instance == null) &#123; synchronized (Singleton.class) &#123;//同步代码块 instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 优缺点：同上（同步方法） 6）双重检查 懒汉式+同步方法+同步代码块 代码实现 1234567891011121314151617class Singleton&#123; private Singleton()&#123;&#125; //使用volatile关键字会强制将修改的值立即写入主存； private static volatile Singleton instance; public static synchronized Singleton getInstance()&#123;//同步方法 if(instance == null)&#123; synchronized(Singleton.class)&#123;//同步代码块 if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优缺点： 优点：保证线程安全，延迟加载，效率较高（实例化代码只用执行一次） 缺点：代码相对较复杂，需要两次 if 检查 推荐使用该种单例设计模式 7）静态内部类 代码实现 12345678910111213141516class Singleton&#123; //构造器私有化 private Singleton()&#123;&#125; private static volatile Singleton instance; //静态内部类，该类中有一个静态属性 Singleton private static class SingletonInstance &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //提供一个静态的公共方法，直接返回 SingletonInstance.INSTANCE public static synchronized Singleton getInstance()&#123; return SingletonInstance.INSTANCE; &#125;&#125; 优缺点： 优点：保证线程安全，延迟加载，效率高 推荐使用 8）枚举 代码实现 123enum Singleton&#123; INSTANCE; //属性&#125; 优缺点： 优点：线程安全，能防止反序列化重新创建新对象 推荐使用 单例模式在 JDK 中的应用 JDK中，java.lang.Runtime 就是经典的单例模式（饿汉式） 注 单例模式保证了系统内存中只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能 当实例化一个单例类的时候，必须要记住使用 相应的获取对象的方法如：getInstance()，而不是去 new 单例模式使用场景：需要频繁进行创建和销毁对象、创建对象时耗时过多或耗费资源过度（重量级对象），但又经常要用到的对象、工具类对象、频繁访问数据库或文件的对象（如：数据源、session工厂）","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Java设计模式学习笔记","slug":"Java设计模式学习笔记","date":"2020-03-03T13:51:20.000Z","updated":"2020-03-12T15:04:32.319Z","comments":true,"path":"2020/03/03/Java设计模式学习笔记/","link":"","permalink":"http://www.tangjian.vip/2020/03/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"谈起设计模式，其实大家多多少少都听说过一些，比如单例模式、工厂模式等等随口就能说出来，但是要我说出具体的细节，或者用代码实现一遍，可能就不知道从何处着手了。所以特意系统的学习一下设计模式，以下就是我的一些学习笔记，如有错误，请不吝指出。 什么是设计模式？ 设计模式其实就是程序员在编程时总结出来的一系列模式、规则，是对软件设计中普遍存在（反复出现）的问题，所提出的解决方案。 设计模式包含了面向对象的精髓，”懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的核心”. 设计模式的目的 代码重用性、可读性、可扩展性、可靠性、高内聚低耦合… 设计模式的七大原则 单一职责原则 接口隔离原则 依赖倒转（倒置）原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则","text":"谈起设计模式，其实大家多多少少都听说过一些，比如单例模式、工厂模式等等随口就能说出来，但是要我说出具体的细节，或者用代码实现一遍，可能就不知道从何处着手了。所以特意系统的学习一下设计模式，以下就是我的一些学习笔记，如有错误，请不吝指出。 什么是设计模式？ 设计模式其实就是程序员在编程时总结出来的一系列模式、规则，是对软件设计中普遍存在（反复出现）的问题，所提出的解决方案。 设计模式包含了面向对象的精髓，”懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的核心”. 设计模式的目的 代码重用性、可读性、可扩展性、可靠性、高内聚低耦合… 设计模式的七大原则 单一职责原则 接口隔离原则 依赖倒转（倒置）原则 里氏替换原则 开闭原则 迪米特法则 合成复用原则 1）单一职责原则对类来说的，即一个类应该只负责一项职责。 2）接口隔离原则客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 3）依赖倒转原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象； 抽象不应该依赖细节，细节应该依赖抽象； 依赖倒转的中心思想是面向接口编程； 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 4）里氏替换原则 在使用继承的时候，遵循里氏替换原则，在子类中尽量不要重写父类的方法； 可以通过聚合、组合来解决问题。 注：聚合关系是整体和部分的关系，整体和部分可以分开（如：电脑由显示器、键盘、鼠标等组成，可以相互分离开）；组合关系也是整体和部分的关系，整体和部分不可以分开（如桌子是有桌子腿和桌面组成，但是他们不能分离开，分开就不是桌子了） 5）开闭原则（OCP） 是编程中最基础、最重要的设计原则 对扩展开放(对提供方)，对修改关闭(对使用方) 6）迪米特法则 一个对象应该对其他对象保持最少的了解 类与类关系越密切，耦合度越大 迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好 只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象有耦合关系，就说这两个对象之间是朋友关系。耦合的方式有很多：依赖、关联、组合、聚合。其中，称出现成员变量、方法参数、返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友。 7）合成复用原则尽量使用合成/聚成的方式，而不是使用继承","categories":[{"name":"Java","slug":"Java","permalink":"http://www.tangjian.vip/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.tangjian.vip/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-02T15:59:36.176Z","updated":"2020-01-02T15:59:36.176Z","comments":true,"path":"2020/01/02/hello-world/","link":"","permalink":"http://www.tangjian.vip/2020/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}